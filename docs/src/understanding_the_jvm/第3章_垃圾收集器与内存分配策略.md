# 第3章 垃圾收集器与内存分配策略
## 3.2 对象已死？（对象存活判定算法）
1. 引用计数法
2. 可达性分析算法

## 3.3 垃圾收集算法
&emsp;&emsp;从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，也常备称作“直接垃圾收集”和“垃圾收集”。引用计数式主流虚拟机中未涉及，本节介绍的算法均属于追踪式垃圾收集的范畴。

名词解释：
- **部分收集（*Partial GC*）**：指目标不是完整收集整个java堆的垃圾收集，其中又分为：
    - **新生代收集（*Minor GC/Young GC*）**：指目标是新生代的垃圾收集。
    - **老年代收集（*Major GC/Old GC*）**：指目标是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
    - **混合收集（*Mixed GC*）**：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- **整堆收集（*Full GC*）**：收集整个Java堆和方法区的垃圾收集。

### 3.3.1 分代收集理论
&emsp;&emsp;当代大部分商用收集器大多遵循了“分代收集理论”（Gerational Collection）。它建立在两条假说之上：
1. **弱分代假说（Weak Generational Hypothesis）**：绝大多数对象都是朝生夕灭的。
2. **强分代假说（Strong Generational Hypothesis）**：熬过越多次垃圾收集过程的对象就越难以消亡。

&emsp;&emsp;假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样9。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

3. **跨代引用假说 （Intergenerational Reference Hypothesis）**：跨代引用相对于同代引用来说仅占极少数。

&emsp;&emsp;这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，计年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

### 3.3.2 垃圾收集算法
- **标记-清除算法**  
  &emsp;&emsp;最早出现、最基础的垃圾收集算法。分为两个阶段：“标记”和“清除”。首先标记出需要回收的对象，统一回收掉所有被标记的对象。也可以标记出存活对象，统一回收未被标记的对象。主要缺点：
  1. 执行效率不稳定。效率随着对象数量增长而降低。
  2. 内存空间碎片化。会产生大量不连续内存碎片，当无法分配较大对象时，会再次出发垃圾收集动作。

- **标记-复制算法**  
  &emsp;&emsp;将内存划分为大小相等的两块。每次使用一块，当一块内存使用完后，将还存活的对象复制到另一块内存上。对于，多数对象时可回收的情况，只需复制少量对象，并对整个半区进行回收，且内存分配时只需移动堆顶指针。主要缺点：
  1. 当大多数对象存活时，增大内存复制开销。
  2. 空间利用率低，可用内存缩小为一半。

- **标记-整理算法**  
  &emsp;&emsp;将对象进行标记，让存活对象移动至内存空间的一端，并清理掉边界以外的内存。

## 3.5 经典垃圾收集器
- **Serial**
  &emsp;&emsp;最基础、历史最悠久的收集器。单线程，采用标记复制算法。
- **ParNew**
  &emsp;&emsp;实质上是Serial收集器的多线程版本，支持多线程并行收集，除此之外无太多创新出。目前仅有它能与CMS收集器配合工作。
- **Parallel Scavenge**
- **CMS** 
- **Serial Old（MSC）**
- **Parallel Old**
- **Garbage First（G1）**
  &emsp;&emsp;为实现“**停顿预测模型**”收集器（能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒），G1开创了**基于Region的内存布局**。虽然G1仍遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。抛开用户线程运行过程动作，G1收集器运作过程大致可划分为一下四个步骤：
  1. **初始标记（Initial Marking）**
  2. **并发标记（Concurrent Marking）**
  3. **最终标记（Final Marking）**
  4. **筛选回收（Live Data Counting and Evacuation）**


## 3.6 低延迟垃圾收集器
- Shenandoah收集器
- ZGC收集器