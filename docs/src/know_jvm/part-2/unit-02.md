# 第2章 Java内存区域与内存溢出异常

## 运行时数据区域
根据《Java虚拟机规范》的规定，Java虚拟机所管理的内存将包括以下几个运行时数据区域：
- **程序计数器**  
  一块较小区域，可以看作是字节码的行号指示器，用来指示下一条需要执行的指令。当线程正在执行一个Java方法，这个计数器应当记录正在执行的字节码指令地址；如果正在执行一个本地（Native）方法，计数器的值应为空（Undefined）。**线程私有**。唯一一个在《Java虚拟机规范》没有规定任何 `OutOfMemoryError` 情况的区域。
- **Java虚拟机栈**  
  虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**线程私有**。
- **本地方法栈**  
  与 **Java虚拟机栈** 非常相似，区别是本地方法栈是为本地（Native）方法服务。**线程私有**。
- **Java堆**  
  是虚拟机管理的最大的一块内存。此区域的唯一目的：**存放对象实例**。当前主流虚拟机都可实现扩展堆的大小（通过参数 `-Xms` 与 `-Xmx` 设定）。如果堆中没有空间完成实例分配，将抛出 `OutOfMemoryError` 异常。虚拟机启动时创建。**线程共享**。
- **方法区**  
  用于加载已被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。**线程共享**。运行是常量池是方法去的一部分，用于存放在编译器生成的各种字面量与符号引用。运行是常量池有一个重要特性：具备动态性；除了编译器产生的常量数据，运行时的数据也可存入。例如：`String` 类的 `intern()` 方法。

以上5个部分共同构成的Java虚拟机的运行时数据区域。但还有一个特殊的内存区域：**直接内存**。**直接内存**并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。在 JDK1.4中新加入了NIO类，它可以使用Native函数库分配堆外内存，并通过存储在Java堆中DirectByteBuffer对象对这块内存进行操控。**因为避免了在Java堆与Native堆中来回复制数据，在某些情况能显著提升性能**。

## 内存细节
如下的相关内存分配、使用等细节，均以 `HotSpot` 虚拟机的堆内存为例。

### 对象的创建
首先，在对象创建之前，必须先执行对应类的[类加载过程](/know_jvm/part-3/unit-07)。随后，在Java堆中划分出一块确定大小的内存用于存放对象数据。  

常见的内存分配的方式有两种：
- **指针碰撞**。Java堆中的内存是规整的（堆空间中一端已使用，一端未使用），用一个指针记录使用与未使用的分界点。分配空间时，将指针像空闲区 域移动一段与对象大小相等的距离。
- **空闲列表**。Java堆中的内存是不规整的（堆空间中已使用与未使用空间相互交错），由虚拟机维护一张可用空间列表。分配空间时，先查询列表，再找到一块足够大的空间并分配，最后更新列表。

具体使用哪一种方式分配内存，取决于Java堆是否规整。而Java堆是否规整，由取决于垃圾收集器是否具有空间压缩整理的能力。

内存分配完成后，将GC分代年龄等信息保存至对象头，将除了对象头以外的空间赋初值。

最后，执行构造函数。

### 对象的内存布局
在 `HotSpot` 虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：**对象头**、**实例数据**、**对齐填充**。

- **对象头**。对象头包括两类信息：对象自身运行时数据（哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）、类型指针（指向此对象类型元数据的指针）。但并不是所有虚拟机都必须在对象数据中保存类型指针。
- **实例数据**。在程序代码中定义的各种字段数据，无论是父类中继承的，还是子类中定义的。各个字段的存储顺序会与定义数据以及分配策略参数（-XX:FieldsAllocationStyle）有关。
- **对其填充**。无特殊意义，起占位符作用。

### 对象的访问定位
Java程序会通过栈上的 `reference` 数据操作对象。`reference` 数据是一个指向对象的引用，通过这个引用访问对象，主流的实现方式有两种：**句柄**、**直接指针**。
- **句柄**。在Java堆中保存句柄池，reference数据存储是对象的句柄地址。句柄中存储了对象的实例数据与类型数据所在地址。优点：当对象移动时（垃圾回收时移动数据），reference无需修改。
  ![句柄方式](/know-jvm/part-2/unit-02/handle.png)
- **直接指针**。reference直接存储对象地址。此时需要考虑类型数据该如何存放。优点：性能更好，节省了一次指针访问开销。`HotSpot` 使用的是直接指针。
  ![直接指针](/know-jvm/part-2/unit-02/direct-pointer.png)
