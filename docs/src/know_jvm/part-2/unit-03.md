# 第3章 垃圾收集器与内存分配策略

本章节讨论如下几个问题：
- 垃圾回收
  1. 如何区分垃圾？
  2. 如何回收垃圾？
  3. 有哪些垃圾收集器？各有什么特点？
- 内存分配策略
  1. 对象分配在哪一块内存上？

##  对象存活判定算法
判断对象是否存活的常用方法有两种：[引用计数算法](#引用计数法)、[可达性分析算法](#可达性分析算法)。

### 引用计数法
在对象中添加一个引用计数器，有一个地方引用它时，计数器值加一；当引用失效时，计数器减一；计数器为零的对象就是不可能再被使用。  
- `优点`：原理简单，判定效率高。  
- `缺点`：还需配合其他额外处理，才能正确工作（此处不做讨论）。例如，当出现循环引用，对象可能将无法被回收。

### 可达性分析算法
通过一系列的`GC Roots`的根对象作为起始节点，从这些节点开始向下搜索，搜索的路径称为“**引用链**”，如果一个对象到`GC Roots`之间没有任何引用相连，则证明对象不可能再被使用。
![可达性分析算法](/know-jvm/part-2/unit-03/reachability-analysis.png)

Java中固定可作为GC Roots的对象有：
- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象
- 虚拟机内部的引用。Class对象，类加载器等
- 被同步锁持有的对象
- JMXBean、JVMTI中注册的回调、本地代码缓存等
- 其他临时性的`GC Roots`。（如垃圾回收器特定的结点，根据不同内存区域的结点）

### 生存还是死亡？
即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：
1. 对象没有与 `GC Roots` 相连的引用链，被第一次标记。
2. 对象没有必要执行 finalize()方法，（没有覆盖 finalize()方法，或者 finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”），被第二次标记。

### 方法区回收
方法区也可以回收，但相较于堆内存来说，回收方法区的效益远低于堆内存。方法区的回收对象主要有：**废弃的常量**、**不再使用的类型**。废弃的常量与回收堆中对象类似，判断是否引用即可。要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了，需要同时满足以下条件：
- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景（典型的如JSP），否则通常是很难达成的。
- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

仅满足上述条件还不行，具体是否清除 `HotSpot` 虚拟机提供了`-Xnoclassgc` 参数进行控制，还可以使用 `-verbose:class` 以及 `-XX:+TraceClass-Loading`、`-XX:+TraceClassUnLoading` 查看类加载和卸载信息

##  垃圾收集算法
&emsp;&emsp;从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，也常备称作“直接垃圾收集”和“垃圾收集”。引用计数式主流虚拟机中未涉及，本节介绍的算法均属于追踪式垃圾收集的范畴。

名词解释：
- **部分收集（*Partial GC*）**：指目标不是完整收集整个java堆的垃圾收集，其中又分为：
    - **新生代收集（*Minor GC/Young GC*）**：指目标是新生代的垃圾收集。
    - **老年代收集（*Major GC/Old GC*）**：指目标是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
    - **混合收集（*Mixed GC*）**：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- **整堆收集（*Full GC*）**：收集整个Java堆和方法区的垃圾收集。

### 分代收集理论
&emsp;&emsp;当代大部分商用收集器大多遵循了“分代收集理论”（Gerational Collection）。它建立在两条假说之上：
1. **弱分代假说（Weak Generational Hypothesis）**：绝大多数对象都是朝生夕灭的。
2. **强分代假说（Strong Generational Hypothesis）**：熬过越多次垃圾收集过程的对象就越难以消亡。

&emsp;&emsp;假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样9。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：

3. **跨代引用假说 （Intergenerational Reference Hypothesis）**：跨代引用相对于同代引用来说仅占极少数。

&emsp;&emsp;这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，计年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。

### 垃圾收集算法
- **标记-清除算法**  
  &emsp;&emsp;最早出现、最基础的垃圾收集算法。分为两个阶段：“标记”和“清除”。首先标记出需要回收的对象，统一回收掉所有被标记的对象。也可以标记出存活对象，统一回收未被标记的对象。主要缺点：
  1. 执行效率不稳定。效率随着对象数量增长而降低。
  2. 内存空间碎片化。会产生大量不连续内存碎片，当无法分配较大对象时，会再次出发垃圾收集动作。

- **标记-复制算法**  
  &emsp;&emsp;将内存划分为大小相等的两块。每次使用一块，当一块内存使用完后，将还存活的对象复制到另一块内存上。对于，多数对象时可回收的情况，只需复制少量对象，并对整个半区进行回收，且内存分配时只需移动堆顶指针。主要缺点：
  1. 当大多数对象存活时，增大内存复制开销。
  2. 空间利用率低，可用内存缩小为一半。

- **标记-整理算法**  
  &emsp;&emsp;将对象进行标记，让存活对象移动至内存空间的一端，并清理掉边界以外的内存。

## 垃圾收集器

### 经典垃圾收集器
- **Serial**：最基础、历史最悠久的收集器。单线程，采用标记复制算法。
- **ParNew**：实质上是Serial收集器的多线程版本，支持多线程并行收集，除此之外无太多创新出。目前仅有它能与CMS收集器配合工作。
- **Parallel Scavenge**
- **CMS** 
- **Serial Old（MSC）**
- **Parallel Old**
- **Garbage First（G1）**：为实现“**停顿预测模型**”收集器（能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒），G1开创了**基于Region的内存布局**。虽然G1仍遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。抛开用户线程运行过程动作，G1收集器运作过程大致可划分为一下四个步骤：
  1. **初始标记（Initial Marking）**
  2. **并发标记（Concurrent Marking）**
  3. **最终标记（Final Marking）**
  4. **筛选回收（Live Data Counting and Evacuation）**

### 低延迟垃圾收集器
- Shenandoah收集器
- ZGC收集器