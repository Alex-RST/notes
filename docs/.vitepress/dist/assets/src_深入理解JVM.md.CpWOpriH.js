import{_ as l,c as i,a0 as r,o as e}from"./chunks/framework.DpdyRgfY.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/深入理解JVM.md","filePath":"src/深入理解JVM.md"}'),o={name:"src/深入理解JVM.md"};function t(n,a,s,h,d,u){return e(),i("div",null,a[0]||(a[0]=[r('<p>[TOC]</p><h2 id="第一部分-走进java" tabindex="-1">第一部分 走进Java <a class="header-anchor" href="#第一部分-走进java" aria-label="Permalink to &quot;第一部分 走进Java&quot;">​</a></h2><h3 id="第1章-走进java" tabindex="-1">第1章 走进Java <a class="header-anchor" href="#第1章-走进java" aria-label="Permalink to &quot;第1章 走进Java&quot;">​</a></h3><p><strong>准确式内存管理</strong> Exact VM使用准确式内存管理，即虚拟机可以知道内存中某个位置的数据具体是什么类型。</p><hr><h2 id="第二部分-自动内存管理" tabindex="-1">第二部分 自动内存管理 <a class="header-anchor" href="#第二部分-自动内存管理" aria-label="Permalink to &quot;第二部分 自动内存管理&quot;">​</a></h2><h3 id="第2章-java内存区域与内存移除异常" tabindex="-1">第2章 java内存区域与内存移除异常 <a class="header-anchor" href="#第2章-java内存区域与内存移除异常" aria-label="Permalink to &quot;第2章 java内存区域与内存移除异常&quot;">​</a></h3><h3 id="第3章-垃圾收集器与内存分配策略" tabindex="-1">第3章 垃圾收集器与内存分配策略 <a class="header-anchor" href="#第3章-垃圾收集器与内存分配策略" aria-label="Permalink to &quot;第3章 垃圾收集器与内存分配策略&quot;">​</a></h3><h4 id="_3-2-对象已死-对象存活判定算法" tabindex="-1">3.2 对象已死？（对象存活判定算法） <a class="header-anchor" href="#_3-2-对象已死-对象存活判定算法" aria-label="Permalink to &quot;3.2 对象已死？（对象存活判定算法）&quot;">​</a></h4><ol><li>引用计数法</li><li>可达性分析算法</li></ol><h4 id="_3-3-垃圾收集算法" tabindex="-1">3.3 垃圾收集算法 <a class="header-anchor" href="#_3-3-垃圾收集算法" aria-label="Permalink to &quot;3.3 垃圾收集算法&quot;">​</a></h4><p>  从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，也常备称作“直接垃圾收集”和“垃圾收集”。引用计数式主流虚拟机中未涉及，本节介绍的算法均属于追踪式垃圾收集的范畴。</p><p>名词解释：</p><ul><li><strong>部分收集（<em>Partial GC</em>）</strong>：指目标不是完整收集整个java堆的垃圾收集，其中又分为： <ul><li><strong>新生代收集（<em>Minor GC/Young GC</em>）</strong>：指目标是新生代的垃圾收集。</li><li><strong>老年代收集（<em>Major GC/Old GC</em>）</strong>：指目标是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。</li><li><strong>混合收集（<em>Mixed GC</em>）</strong>：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li><strong>整堆收集（<em>Full GC</em>）</strong>：收集整个Java堆和方法区的垃圾收集。</li></ul><h5 id="_3-3-1-分代收集理论" tabindex="-1">3.3.1 分代收集理论 <a class="header-anchor" href="#_3-3-1-分代收集理论" aria-label="Permalink to &quot;3.3.1 分代收集理论&quot;">​</a></h5><p>  当代大部分商用收集器大多遵循了“分代收集理论”（Gerational Collection）。它建立在两条假说之上：</p><ol><li><strong>弱分代假说（Weak Generational Hypothesis）</strong>：绝大多数对象都是朝生夕灭的。</li><li><strong>强分代假说（Strong Generational Hypothesis）</strong>：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ol><p>  假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样9。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p><ol start="3"><li><strong>跨代引用假说 （Intergenerational Reference Hypothesis）</strong>：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>  这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，计年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p><h5 id="_3-3-2-垃圾收集算法" tabindex="-1">3.3.2 垃圾收集算法 <a class="header-anchor" href="#_3-3-2-垃圾收集算法" aria-label="Permalink to &quot;3.3.2 垃圾收集算法&quot;">​</a></h5><ul><li><p><strong>标记-清除算法</strong><br>   最早出现、最基础的垃圾收集算法。分为两个阶段：“标记”和“清除”。首先标记出需要回收的对象，统一回收掉所有被标记的对象。也可以标记出存活对象，统一回收未被标记的对象。主要缺点：</p><ol><li>执行效率不稳定。效率随着对象数量增长而降低。</li><li>内存空间碎片化。会产生大量不连续内存碎片，当无法分配较大对象时，会再次出发垃圾收集动作。</li></ol></li><li><p><strong>标记-复制算法</strong><br>   将内存划分为大小相等的两块。每次使用一块，当一块内存使用完后，将还存活的对象复制到另一块内存上。对于，多数对象时可回收的情况，只需复制少量对象，并对整个半区进行回收，且内存分配时只需移动堆顶指针。主要缺点：</p><ol><li>当大多数对象存活时，增大内存复制开销。</li><li>空间利用率低，可用内存缩小为一半。</li></ol></li><li><p><strong>标记-整理算法</strong><br>   将对象进行标记，让存活对象移动至内存空间的一端，并清理掉边界以外的内存。</p></li></ul><h4 id="_3-5-经典垃圾收集器" tabindex="-1">3.5 经典垃圾收集器 <a class="header-anchor" href="#_3-5-经典垃圾收集器" aria-label="Permalink to &quot;3.5 经典垃圾收集器&quot;">​</a></h4><ul><li><strong>Serial</strong>   最基础、历史最悠久的收集器。单线程，采用标记复制算法。</li><li><strong>ParNew</strong>   实质上是Serial收集器的多线程版本，支持多线程并行收集，除此之外无太多创新出。目前仅有它能与CMS收集器配合工作。</li><li><strong>Parallel Scavenge</strong></li><li><strong>CMS</strong></li><li><strong>Serial Old（MSC）</strong></li><li><strong>Parallel Old</strong></li><li><strong>Garbage First（G1）</strong>   为实现“<strong>停顿预测模型</strong>”收集器（能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒），G1开创了<strong>基于Region的内存布局</strong>。虽然G1仍遵循分代收集理论，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。抛开用户线程运行过程动作，G1收集器运作过程大致可划分为一下四个步骤： <ol><li><strong>初始标记（Initial Marking）</strong></li><li><strong>并发标记（Concurrent Marking）</strong></li><li><strong>最终标记（Final Marking）</strong></li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong></li></ol></li></ul><h4 id="_3-6-低延迟垃圾收集器" tabindex="-1">3.6 低延迟垃圾收集器 <a class="header-anchor" href="#_3-6-低延迟垃圾收集器" aria-label="Permalink to &quot;3.6 低延迟垃圾收集器&quot;">​</a></h4><ul><li>Shenandoah收集器</li><li>ZGC收集器</li></ul><h3 id="第4章-虚拟机性能监控和故障处理工具" tabindex="-1">第4章 虚拟机性能监控和故障处理工具 <a class="header-anchor" href="#第4章-虚拟机性能监控和故障处理工具" aria-label="Permalink to &quot;第4章 虚拟机性能监控和故障处理工具&quot;">​</a></h3><ul><li>jps</li><li>jstat</li><li>jinfo</li><li>jmap</li><li>jhat</li><li>jstack</li><li>...</li></ul><h3 id="第5章-调优案例分析与实战" tabindex="-1">第5章 调优案例分析与实战 <a class="header-anchor" href="#第5章-调优案例分析与实战" aria-label="Permalink to &quot;第5章 调优案例分析与实战&quot;">​</a></h3><hr><h2 id="第三部分-虚拟机执行子系统" tabindex="-1">第三部分 虚拟机执行子系统 <a class="header-anchor" href="#第三部分-虚拟机执行子系统" aria-label="Permalink to &quot;第三部分 虚拟机执行子系统&quot;">​</a></h2><h3 id="第6章-类文件结构" tabindex="-1">第6章 类文件结构 <a class="header-anchor" href="#第6章-类文件结构" aria-label="Permalink to &quot;第6章 类文件结构&quot;">​</a></h3><h3 id="第7章-虚拟机类加载机制" tabindex="-1">第7章 虚拟机类加载机制 <a class="header-anchor" href="#第7章-虚拟机类加载机制" aria-label="Permalink to &quot;第7章 虚拟机类加载机制&quot;">​</a></h3><h4 id="_7-1-类加载的时机" tabindex="-1">7.1 类加载的时机 <a class="header-anchor" href="#_7-1-类加载的时机" aria-label="Permalink to &quot;7.1 类加载的时机&quot;">​</a></h4><p>  一个类型（Class、Interface、二进制流形式的class文件等）从被虚拟机加载到内存中开始，到卸载出内存为止，它的整个生命周期会经历<strong>七个阶段</strong>，分别是：<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initializaion）、使用（Using）、卸载（Unloading）</strong>。其中验证、准备、解析三个部分统称 为<strong>连接</strong>。</p><h3 id="第8章-虚拟机字节码执行引擎" tabindex="-1">第8章 虚拟机字节码执行引擎 <a class="header-anchor" href="#第8章-虚拟机字节码执行引擎" aria-label="Permalink to &quot;第8章 虚拟机字节码执行引擎&quot;">​</a></h3><h3 id="第9章-类加载及执行子系统的案例与实战" tabindex="-1">第9章 类加载及执行子系统的案例与实战 <a class="header-anchor" href="#第9章-类加载及执行子系统的案例与实战" aria-label="Permalink to &quot;第9章 类加载及执行子系统的案例与实战&quot;">​</a></h3><hr><h2 id="第四部分-程序编译与代码优化" tabindex="-1">第四部分 程序编译与代码优化 <a class="header-anchor" href="#第四部分-程序编译与代码优化" aria-label="Permalink to &quot;第四部分 程序编译与代码优化&quot;">​</a></h2><h3 id="第10章-前端编译与优化" tabindex="-1">第10章 前端编译与优化 <a class="header-anchor" href="#第10章-前端编译与优化" aria-label="Permalink to &quot;第10章 前端编译与优化&quot;">​</a></h3><h4 id="_10-1-概述" tabindex="-1">10.1 概述 <a class="header-anchor" href="#_10-1-概述" aria-label="Permalink to &quot;10.1 概述&quot;">​</a></h4><p>Java技术下的编译器类型：</p><ul><li><strong>前端编译器</strong>：把*.java文件转变为*.class的过程。</li><li><strong>即时编译器（<em>JIT, Just In Time Compiler</em>）</strong>：运行期把字节码转变成本地机器码的过程。</li><li><strong>提前编译器（<em>AOT, Ahead Of Time Compiler</em>）</strong>：直接把程序编译成与目标机器指令集相关的二进制代码的过程。</li></ul><h4 id="_10-2-javac编译器" tabindex="-1">10.2 Javac编译器 <a class="header-anchor" href="#_10-2-javac编译器" aria-label="Permalink to &quot;10.2 Javac编译器&quot;">​</a></h4><p>从Javac代码整体来看，编译过程大致分为1个准备过程，三个处理过程：</p><ol><li>准备过程：初始化插入式注解处理器。</li><li>解析与填充符号表过程，包括： <ul><li>词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。</li><li>填充符号。产生地址和符号信息。</li></ul></li><li>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段。</li><li>分析与字节码生成过程，包括： <ul><li>标注检查。对语法的静态信息进行检查。</li><li>数据流及控制流分析。对程序动态过程进行检查。</li><li>解语法糖。将简化代码编写的语法糖还原为原有的形式。</li><li>字节码生成。将前面各个步骤所生成的信息转化为字节码。</li></ul></li></ol><p>上述三个处理过程里，执行插入式注解时又可能产生新的符号，如果有新的符号产生就必须回到之前的解析、填充符号表的过程中重新处理这些新的符号。</p><h3 id="第11章-后端编译与优化" tabindex="-1">第11章 后端编译与优化 <a class="header-anchor" href="#第11章-后端编译与优化" aria-label="Permalink to &quot;第11章 后端编译与优化&quot;">​</a></h3><h4 id="_11-2-即时编译器" tabindex="-1">11.2 即时编译器 <a class="header-anchor" href="#_11-2-即时编译器" aria-label="Permalink to &quot;11.2 即时编译器&quot;">​</a></h4><p>目前主流的Java虚拟机（HotSpot、OpenJ9），Java程序最初都是通过解释器（Interpreter）解释执行，当发现一段代码运行频繁，在运行时会将这些代码编译为本地机器码。运行时完成这个任务的后端编译器成为<strong>即时编译器</strong>。</p><p>HotSpot虚拟机内置了两个（或三个）即时编译器，可以通过“-client”或“-server”参数强制指定在那种模式下运行：</p><ul><li>客户端编译器（Client Compiler）或者简称C1编译器。“-client”。</li><li>服务端编译器（Server Compiler）或者简称C2编译器。“-server”。</li></ul><p>解释器与编译器使用方式有三种：（可以使用“-version”参数显示模式）</p><ul><li>混合模式</li><li>解释模式：使用“-Xint”参数强制进入“解释模式”。编译器完全不介入，所有代码都解释执行。</li><li>编译模式：使用“-Xcomp”参数强制进入“编译模式”。将优先采用编译执行，解释器在编译无法进行的情况下介入。</li></ul><p>在运行过程中会被即时编译器编译的目标成为“热点代码”，主要有两类：</p><ul><li>被多次调用的方法。</li><li>被多次执行的循环体。</li></ul><p>热点代码探测判定方式，主要有两种：</p><ul><li><strong>基于采样的热点探测</strong>。虚拟机周期性的检查各个线程调用栈顶。将经常出现在栈顶的方法认定为“热点方法”。</li><li><strong>基于计数器的热点探测</strong>。虚拟机为每个方法（甚至代码块）建立计数器，当超过阈值则认定为“热点方法”。</li></ul><p>  为了实现基于计数的热点探测，HotSpot为每个方法准备了两类计数器：<strong>方法调用计数器</strong>（Invocation Counter）、<strong>回边计数器</strong>（Back Edge Counter）。 两个计数器都有明确阈值，当阈值溢出，触发即时编译。</p><p>  <strong>方法调用计数器</strong>。统计方法被调用的次数。可通过“<strong>-XX:CompileThreshold</strong>”设定。当方法被调用时，虚拟机会检查该方法是否存在被即时编译过的版本，如果存在，则优先使用编译后的代码。如果不存在，则将方法调用计数器值加一，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器阈值。一旦超过阈值，将会向即时编译器提交一个该方法的代码编译请求。</p><p>  <strong>回边计数器</strong>。作用是统计方法中循环体现代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”。</p><h4 id="_11-3-提前编译器" tabindex="-1">11.3 提前编译器 <a class="header-anchor" href="#_11-3-提前编译器" aria-label="Permalink to &quot;11.3 提前编译器&quot;">​</a></h4><p>提前编译有两条明细分支：</p><ol><li>在程序运行之前把程序代码编译成机器码的静态编译工作（传统C/C++编译方式）。</li><li>在原本即时编译器在运行时要做的编译工作提前做好并保存下来。</li></ol><hr><h2 id="第五部分-高效并发" tabindex="-1">第五部分 高效并发 <a class="header-anchor" href="#第五部分-高效并发" aria-label="Permalink to &quot;第五部分 高效并发&quot;">​</a></h2><h3 id="第12章-java内存模型与线程" tabindex="-1">第12章 Java内存模型与线程 <a class="header-anchor" href="#第12章-java内存模型与线程" aria-label="Permalink to &quot;第12章 Java内存模型与线程&quot;">​</a></h3><h3 id="第13章-线程安全与锁优化" tabindex="-1">第13章 线程安全与锁优化 <a class="header-anchor" href="#第13章-线程安全与锁优化" aria-label="Permalink to &quot;第13章 线程安全与锁优化&quot;">​</a></h3>',68)]))}const p=l(o,[["render",t]]);export{c as __pageData,p as default};
